Iceberg에서 "테이블 커밋의 선형적 역사를 보장한다"는 것은 테이블에 대한 모든 변경 사항(데이터 추가, 수정, 삭제 등)이 시간 순서대로 기록되어 명확한 타임라인을 형성한다는 의미입니다. 마치 버전 관리 시스템에서 커밋 히스토리가 선형적으로 기록되는 것과 유사합니다.

이것이 "동시 쓰기"(concurrent writes) 상황에서 중요한 이유는 다음과 같습니다:

1. **일관성 유지**: 여러 쿼리 엔진이 동시에 같은 테이블에 데이터를 쓸 때, atomic한 메타데이터 생성 방식은 각 쓰기 작업이 순차적으로 커밋되도록 보장합니다. 이렇게 하면 어떤 쓰기 작업도 다른 작업에 의해 부분적으로 덮어쓰이거나 손상되지 않습니다.
2. **경쟁 조건 방지**: 두 엔진이 동시에 테이블에 쓰려고 할 때, Iceberg는 각 쓰기 작업이 완료될 때마다 새로운 메타데이터 파일을 원자적으로 생성합니다. 이는 "누가 마지막으로 썼는가"에 대한 경쟁 조건을 방지합니다.
3. **롤백 및 복구 가능**: 선형적 역사는 문제가 발생했을 때 특정 시점으로 롤백하거나 특정 커밋에서 데이터를 복구하는 것을 용이하게 합니다.
4. **시간 여행 쿼리 지원**: 과거 버전의 테이블 상태를 쉽게 조회할 수 있게 합니다.

또한, 읽기 작업 중에 "엔진이 항상 테이블의 최신 버전을 볼 수 있다"는 것은 다음을 의미합니다:

- 어떤 읽기 작업이 시작될 때, 그 시점에서 가장 최근에 성공적으로 커밋된 테이블 상태를 보게 됩니다.
- 읽기 작업은 진행 중인(아직 완료되지 않은) 쓰기 작업의 부분적인 결과를 보지 않습니다.
- 이는 "읽기 일관성"(read consistency)을 보장하여, 쿼리가 항상 일관된 데이터 상태를 기반으로 실행되도록 합니다.

이러한 메커니즘은 결국 데이터 레이크 환경에서 트랜잭션 데이터베이스와 유사한 일관성과 격리 수준을 제공하는 데 도움이 됩니다.

------------

##### Q. 여러 쿼리 엔진이 같은 테이블에 동시에 쓰게 되면 왜 다른 작업에 의해 부분적으로 덮어쓰이거나 손상되지 않는거야

Iceberg 테이블 형식의 설계에서는 여러 쿼리 엔진이 동시에 같은 테이블에 쓰더라도 데이터가 손상되지 않도록 보호하는 메커니즘이 있습니다. 이것이 가능한 이유는 다음과 같습니다:

1. **파일 추가 방식의 설계**: Iceberg는 기존 데이터 파일을 직접 수정하지 않고, 새로운 데이터 파일을 추가하는 방식으로 작동합니다. 각 쓰기 작업은 새로운 파일을 생성하므로, 기존 파일을 덮어쓰는 일이 발생하지 않습니다.
2. **원자적(Atomic) 메타데이터 업데이트**: 가장 중요한 부분은 메타데이터 파일이 원자적으로 업데이트된다는 점입니다. 즉, 쓰기 작업이 완료되면 메타데이터 파일이 한 번에 교체됩니다. 이 과정에서:
    - 각 쓰기 작업은 먼저 데이터 파일을 씁니다.
    - 그 다음 새로운 메타데이터 파일을 생성합니다.
    - 마지막으로, 카탈로그의 메타데이터 포인터를 원자적으로 업데이트하여 새 메타데이터 파일을 가리키게 합니다.
3. **낙관적 동시성 제어(Optimistic Concurrency Control)**: Iceberg는 낙관적 동시성 제어를 사용합니다. 두 쿼리 엔진이 동시에 같은 테이블에 쓰려고 할 때:
    - 각 엔진은 현재 메타데이터 버전을 읽습니다.
    - 자신의 데이터 파일을 씁니다.
    - 새 메타데이터 파일을 생성합니다.
    - 메타데이터 포인터를 업데이트하려고 시도합니다.
    - 이때 다른 엔진이 이미 메타데이터를 업데이트했다면, 충돌이 감지되고 첫 번째 엔진은 재시도하거나 작업을 취소합니다.

이러한 방식으로 Iceberg는 여러 엔진이 동시에 쓰더라도 항상 일관된 상태를 유지하고, 데이터가 손상되거나 부분적으로 덮어쓰이는 것을 방지합니다. 결과적으로, 테이블의 상태는 항상 완전히 커밋된 트랜잭션의 결과만을 반영하게 됩니다.